package state

import (
	"echo/constants"
	"echo/lib/utils"
	"echo/lib/wss"
	"errors"
	"io"
	"log"
	"sync"

	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
)

type MemberId = int

type Member struct {
	mu                  sync.Mutex
	Id                  MemberId
	Conn                *webrtc.PeerConnection
	Tracks              []*webrtc.TrackLocalStaticRTP
	Socket              *wss.Socket
	TracksChannel       chan *webrtc.TrackLocalStaticRTP
	PeerConnectionState chan webrtc.PeerConnectionState
	Audio               bool
	Video               bool
	rtpSenders          []*webrtc.RTPSender
}

func initPeerConnection() (*webrtc.PeerConnection, error) {
	mediaEngine := &webrtc.MediaEngine{}

	// register video (vp8) codec
	if err := mediaEngine.RegisterCodec(
		webrtc.RTPCodecParameters{
			RTPCodecCapability: webrtc.RTPCodecCapability{
				MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
			},
			PayloadType: 96,
		}, webrtc.RTPCodecTypeVideo,
	); err != nil {
		panic(err)
	}

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	// create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	interceptorRegistry := &interceptor.Registry{}

	// use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(mediaEngine, interceptorRegistry); err != nil {
		return nil, err
	}

	// register a intervalpli factory
	// this interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// this makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// TODO: A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		return nil, err
	}

	interceptorRegistry.Add(intervalPliFactory)

	// create a new peer connection
	conn, err := webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithInterceptorRegistry(interceptorRegistry),
	).NewPeerConnection(constants.Config)

	return conn, err
}

// Initialize a peer connection and create a new member struct associated to the connection
func NewMember(mid MemberId, socket *wss.Socket) (*Member, error) {
	conn, err := initPeerConnection()
	if err != nil {
		return nil, err
	}

	member := Member{
		Id:                  mid,
		Conn:                conn,
		Tracks:              []*webrtc.TrackLocalStaticRTP{},
		Socket:              socket,
		TracksChannel:       make(chan *webrtc.TrackLocalStaticRTP),
		PeerConnectionState: make(chan webrtc.PeerConnectionState),
		Audio:               false,
		Video:               false,
	}

	conn.OnTrack(member.onTrack)
	conn.OnICECandidate(member.onICECandidate)
	conn.OnConnectionStateChange(member.onConnectionStateChange)
	conn.OnICEConnectionStateChange(member.onICEConnectionStateChange)
	conn.OnICEGatheringStateChange(member.onICEGatheringStateChange)
	conn.OnNegotiationNeeded(member.onNegotiationNeeded)

	return &member, nil
}

func (m *Member) onTrack(remoteTrack *webrtc.TrackRemote, _ *webrtc.RTPReceiver) {

	log.Printf("received a remote %s track", remoteTrack.Kind().String())

	// create a local track with the remote track capabilities
	localTrack, err := webrtc.NewTrackLocalStaticRTP(
		remoteTrack.Codec().RTPCodecCapability,
		remoteTrack.ID(),
		remoteTrack.ID(),
	)

	if err != nil {
		log.Println("error creating a local track:", err)
		return
	}

	m.Tracks = append(m.Tracks, localTrack)

	m.TracksChannel <- localTrack

	// write the buffer from the remote track in the local track simultaneously
	// codec := remoteTrack.Codec()
	// writer := record.GetWriter(codec)

	go func() {
		utils.IncreaseThread()
		defer utils.DecreaseThread()
		for {
			packet, _, err := remoteTrack.ReadRTP()
			if err != nil {
				log.Println("[onTrack]", err)
				break
			}

			// record.SavePacketToDisk(writer, packet)
			// ErrClosedPipe means we don't have any subscribers, this is ok if no peers have connected yet
			if err := localTrack.WriteRTP(packet); err != nil && !errors.Is(err, io.ErrClosedPipe) {
				log.Println("[onTrack]", err)
				break
			}
		}
	}()
}

func (m *Member) onICECandidate(candidate *webrtc.ICECandidate) {
	if candidate == nil {
		log.Printf("Got a null candiate; Ice gathering done.")
		return
	}

	ice := candidate.ToJSON()
	m.Socket.SendIceCandidateMessage(&ice)
}

func (m *Member) onConnectionStateChange(cs webrtc.PeerConnectionState) {
	log.Printf("Connection state: %s", cs.String())
	if cs == webrtc.PeerConnectionStateClosed {
		m.cleanup()
	}
	m.PeerConnectionState <- cs
}

func (m *Member) cleanup() {
	for _, sender := range m.rtpSenders {
		sender.Stop()
	}
}

func (m *Member) onICEConnectionStateChange(is webrtc.ICEConnectionState) {
	log.Printf("Ice connection state: %s", is.String())
}

func (m *Member) onICEGatheringStateChange(is webrtc.ICEGatheringState) {
	log.Printf("Ice gathering state: %s", is.String())
}

func (m *Member) onNegotiationNeeded() {
	log.Println("negotiation needed")

	transceivers := m.Conn.GetTransceivers()
	// only add transceivers incase they are not added yet.
	if len(transceivers) == 0 {
		// add receive only audio transceiver (must be first, will have mid=0)
		m.Conn.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio, webrtc.RTPTransceiverInit{
			Direction: webrtc.RTPTransceiverDirectionRecvonly,
		})
		// add receive only video transceiver (must be the second, will have mid=1)
		m.Conn.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo, webrtc.RTPTransceiverInit{
			Direction: webrtc.RTPTransceiverDirectionRecvonly,
		})
	}

	localSdp := utils.Must(m.Conn.CreateOffer(nil))
	utils.Unwrap(m.Conn.SetLocalDescription(localSdp))

	m.Socket.SendOfferMessage(&localSdp)
}

func (m *Member) SendTrack(track *webrtc.TrackLocalStaticRTP) error {
	rtpSender, err := m.Conn.AddTrack(track)
	if err != nil {
		log.Printf(
			"Unable to add track to peer (%d) connection: %s",
			m.Id,
			err,
		)
		return err
	}
	m.rtpSenders = append(m.rtpSenders, rtpSender)

	// Read incoming RTCP packets
	// Before these packets are returned they are processed by interceptors. For things
	// like NACK this needs to be called.
	go func() {
		utils.IncreaseThread()
		defer utils.DecreaseThread()
		rtcpBuf := make([]byte, 1500)
		for {
			if _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {
				log.Printf(
					"Unable to read rtcp for peer %d: %s",
					m.Id,
					rtcpErr,
				)
				return
			}
		}
	}()

	return nil
}

func (m *Member) SetAudio(audio bool) {
	m.Audio = audio
}

func (m *Member) SetVideo(video bool) {
	m.Video = video
}
