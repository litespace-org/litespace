package state

import (
	"echo/constants"
	"echo/lib/record"
	"echo/lib/utils"
	"encoding/json"
	"errors"
	"io"
	"log"
	"time"

	"github.com/gofiber/contrib/websocket"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
)

type Slot struct {
	peerId int
	audio  *webrtc.RTPTransceiver
	video  *webrtc.RTPTransceiver
}

// this describes a (current, or inadvance) peer connection between the client
// (producer/consumer) and the server.
type PeerContainer struct {
	Id   int
	Conn *webrtc.PeerConnection

	// slice of tracks that are received from the client in the server
	Tracks []*webrtc.TrackLocalStaticRTP

	// the associated websocket connection
	Socket *websocket.Conn

	// the associated data channel container
	DataChannel *DataChannelContainer

	// recieved (by websocket) ice-candidates are stored here when connection is not established yet
	iceCandidates []string

	onDestroy  map[int]func(*PeerContainer)
	onNewTrack map[int]func(*webrtc.TrackLocalStaticRTP)

	// indicates whether the Destroy method has invoked or not; this avoid segmentation errors
	Destroyed bool

	// list of peer containers that consumes from this one
	consumers map[int]*PeerContainer

	// list of slots that are available for this container to fill with producers
	slots []Slot
}

func NewPeerContainer(
	id int,
	conn *webrtc.PeerConnection,
	socket *websocket.Conn,
	onDestroy func(*PeerContainer),
) PeerContainer {
	onDestroyMap := make(map[int]func(*PeerContainer))
	onDestroyMap[0] = onDestroy
	return PeerContainer{
		Id:            id,
		Conn:          conn,
		Socket:        socket,
		Tracks:        []*webrtc.TrackLocalStaticRTP{},
		iceCandidates: []string{},
		consumers:     make(map[int]*PeerContainer),
		onDestroy:     onDestroyMap,
		onNewTrack:    make(map[int]func(*webrtc.TrackLocalStaticRTP)),
		slots:         []Slot{},
	}
}

func (pc *PeerContainer) CountHandlers() int {
	return len(pc.onDestroy) + len(pc.onNewTrack)
}

/*
establish a webrtc peer connection by using pion webrtc. this function does
more than establishing the connection; it manages the global state of peers
connections and streams as well.

Note: it returns the peer connection with the associated id if it's already
established before, by retrieving it from the state package.
*/
func (pc *PeerContainer) InitConn() (*webrtc.PeerConnection, error) {
	if pc.Destroyed == true {
		pc.Destroyed = false
	}

	if pc.Conn != nil {
		return nil, errors.New("connection is already initialized")
	}

	mediaEngine := &webrtc.MediaEngine{}

	// Register video (vp8) codec
	err := mediaEngine.RegisterCodec(
		webrtc.RTPCodecParameters{
			RTPCodecCapability: webrtc.RTPCodecCapability{
				MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
			},
			PayloadType: 96,
		}, webrtc.RTPCodecTypeVideo,
	)

	if err != nil {
		panic(err)
	}

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	interceptorRegistry := &interceptor.Registry{}

	// Use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(mediaEngine, interceptorRegistry); err != nil {
		return nil, err
	}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// TODO: A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		return nil, err
	}
	interceptorRegistry.Add(intervalPliFactory)

	// Create a new RTCPeerConnection
	conn, err := webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithInterceptorRegistry(interceptorRegistry),
	).NewPeerConnection(constants.Config)

	for range constants.MAX_MEMBERS_NUM {
		conn.AddTransceiverFromKind(webrtc.RTPCodecTypeAudio)
		conn.AddTransceiverFromKind(webrtc.RTPCodecTypeVideo)
	}

	conn.OnTrack(pc.onTrack)
	conn.OnICECandidate(pc.onICECandidate)
	conn.OnConnectionStateChange(pc.onConnectionStateChange)

	conn.OnICEConnectionStateChange(func(is webrtc.ICEConnectionState) {
		log.Printf("Ice connection state: %s", is.String())
	})
	conn.OnICEGatheringStateChange(func(is webrtc.ICEGatheringState) {
		log.Printf("Ice gathering state: %s", is.String())
	})

	conn.OnDataChannel(func(dc *webrtc.DataChannel) {
		log.Println("data channel recieved from peer", pc.Id, "with label", dc.Label())
		pc.DataChannel = &DataChannelContainer{
			Channel: dc,
			OnNewMessage: func(msg *DataChannelMsg) {
				pc.AddICECandidate(msg.NewIceCandidate)
			},
		}
		if err := pc.DataChannel.Init(); err != nil {
			log.Println("peer", pc.Id, ": failed to init data channel!")
			log.Println("error:", err)
		}
	})

	pc.Conn = conn
	return conn, err
}

func (pc *PeerContainer) AddICECandidate(candidate string) {
	if pc.Conn == nil {
		pc.iceCandidates = append(pc.iceCandidates, candidate)
		return
	}
	ice := &webrtc.ICECandidateInit{}
	if err := json.Unmarshal([]byte(candidate), ice); err != nil {
		log.Println("error:", err)
		return
	}
	if err := pc.Conn.AddICECandidate(*ice); err != nil {
		log.Println("warning: candidate couldn't be added.")
		log.Println("error:", err)
		return
	}
}

/*
initialize this list of slots of this container. It should be used after the connectio is established.
*/
func (pc *PeerContainer) initSlots() error {
	if len(pc.slots) > 0 {
		return errors.New("slots already initialized.")
	}
	if pc.Conn == nil {
		return errors.New("no connection established.")
	}
	// assuming its a bunch of consicutive audio-video transceivers
	// where eachone is supposed to represent a `Slot`.
	transceivers := pc.Conn.GetTransceivers()
	for i := range len(transceivers) {
		if i%2 != 0 {
			continue
		}
		pc.slots = append(pc.slots, Slot{
			peerId: 0,
			audio:  transceivers[i],
			video:  transceivers[i+1],
		})
	}
	pc.slots[0].peerId = pc.Id
	return nil
}

// returns an empty slot for a peer container (producer), or the associated slot if found
func (pc *PeerContainer) getSlotFor(peerId int) *Slot {
	if len(pc.slots) == 0 {
		return nil
	}
	var emptySlotIndex int
	for i, slot := range pc.slots {
		if slot.peerId == peerId {
			return &slot
		}
		if slot.peerId == 0 && emptySlotIndex == 0 {
			emptySlotIndex = i
		}
	}
	pc.slots[emptySlotIndex].peerId = peerId
	return &pc.slots[emptySlotIndex]
}

/*
This function should be used in the consume handler in order to send producer
tracks to consumers (this peer container) by using webrtc.RTPSender.
*/
func (pc *PeerContainer) consumeTrack(peerId int, track *webrtc.TrackLocalStaticRTP) error {
	if r := recover(); r != nil {
		return errors.New("PANIC error occured in consumeTrack method!")
	}
	var err error = nil
	pc.initSlots()

	slot := pc.getSlotFor(peerId)
	log.Println("FOR", peerId, slot)
	if slot == nil {
		return errors.New("no available slot")
	}

	// replace track
	if track.Kind() == webrtc.RTPCodecTypeAudio {
		slot.audio.Sender().ReplaceTrack(track)
	} else if track.Kind() == webrtc.RTPCodecTypeVideo {
		slot.video.Sender().ReplaceTrack(track)
	} else {
		return errors.New("invalid track codec type.")
	}

	return err
}

/*
Get tracks from some peer container and cosume or send them to the owner
of the current peer container
*/
func (pc *PeerContainer) Consume(producer *PeerContainer) error {
	if producer.consumers[pc.Id] != nil {
		return nil
	}

	for _, track := range producer.Tracks {
		err := pc.consumeTrack(producer.Id, track)
		if err != nil {
			log.Println("consume error:", err)
			return err
		}
	}

	producer.AddConsumer(pc)

	producer.AddOnNewTrackHandler(pc.Id, func(track *webrtc.TrackLocalStaticRTP) {
		err := pc.consumeTrack(producer.Id, track)
		if err != nil {
			log.Println("consume error:", err)
		}
	})

	producer.AddOnDestroyHandler(pc.Id, func(self *PeerContainer) {
		slot := pc.getSlotFor(producer.Id)
		if slot != nil {
			slot.peerId = 0
		}
	})

	pc.AddOnDestroyHandler(pc.Id, func(pc *PeerContainer) {
		producer.RmvConsumer(pc.Id)
	})
	return nil
}

// close both webrtc and socket connections, and clear variables from memory
func (pc *PeerContainer) Destroy() {
	if pc.Destroyed {
		return
	}
	pc.destroyPeer()
	pc.destroySocket()
	pc.Destroyed = true
	for _, fn := range pc.onDestroy {
		fn(pc)
	}
	delete(pc.onDestroy, pc.Id)
	for _, slot := range pc.slots {
		slot.audio.Stop()
		slot.video.Stop()
	}
	pc.slots = []Slot{}
}

func (pc *PeerContainer) destroyPeer() {
	if pc.Conn != nil {
		// ignore any error
		if err := pc.Conn.Close(); err != nil {
		}
	}
	if pc.DataChannel != nil {
		// ignore any error
		if err := pc.DataChannel.Destroy(); err != nil {
		}
	}
	pc.Conn = nil
	pc.DataChannel = nil
	pc.Tracks = nil
}

func (pc *PeerContainer) destroySocket() {
	if pc.Socket != nil {
		// this terminates the hanging in the ws handler for loop
		pc.Socket.SetReadDeadline(<-time.NewTimer(5 * time.Second).C)
		// ignore any error
		if err := pc.Socket.Close(); err != nil {
		}
	}
	pc.Socket = nil
}

// store different tracks received from the remote peer in the state
func (pc *PeerContainer) onTrack(remoteTrack *webrtc.TrackRemote, _ *webrtc.RTPReceiver) {
	// create a local track with the remote track capabilities
	localTrack, newTrackErr := webrtc.NewTrackLocalStaticRTP(
		remoteTrack.Codec().RTPCodecCapability,
		remoteTrack.ID(),
		remoteTrack.ID(),
	)

	if newTrackErr != nil {
		panic(newTrackErr)
	}

	pc.Tracks = append(pc.Tracks, localTrack)
	for _, fn := range pc.onNewTrack {
		go fn(localTrack)
	}

	// write the buffer from the remote track in the local track simultaneously
	codec := remoteTrack.Codec()
	writer := record.GetWriter(codec)

	utils.IncreaseThread()
	defer utils.DecreaseThread()
	for {
		packet, _, readErr := remoteTrack.ReadRTP()
		record.SavePacketToDisk(writer, packet)
		if readErr != nil {
			log.Println(readErr)
			break
		}
		// ErrClosedPipe means we don't have any subscribers, this is ok if no peers have connected yet
		if err := localTrack.WriteRTP(packet); err != nil && !errors.Is(err, io.ErrClosedPipe) {
			log.Println(err)
			break
		}
	}
}

// When Pion gathers a new ICE Candidate send it to the client. This is how
// ice trickle is implemented. Everytime we have a new candidate available we send
// it as soon as it is ready. We don't wait to emit a Offer/Answer until they are
// all available
func (pc *PeerContainer) onICECandidate(candidate *webrtc.ICECandidate) {
	if candidate != nil {
		log.Printf("Ice candiate: %s/%s", candidate.Typ.String(), candidate.Protocol.String())
	}

	if candidate == nil {
		log.Printf("Got a null candiate; Ice gathering done.")
		return
	}

	if pc.Socket == nil && pc.DataChannel == nil {
		// NOTE: this should never happen as the specification is that:
		// the connection cannot be established without sockets exist, and once it's
		// established sockets are closed and replaced by data channels for further
		// communication.
		log.Println("error: neither socket nor data channel is found; should never happen!")
		return
	}

	iceInit, err := json.Marshal(candidate.ToJSON())
	if err != nil {
		log.Println("error:", err)
		return
	}

	if pc.Socket != nil {
		pc.Socket.WriteMessage(websocket.TextMessage, iceInit)
		return
	}
	pc.DataChannel.Send(DataChannelMsg{
		NewIceCandidate: string(iceInit),
	})
}

// Hanldes the container state and behaviour according to the connection state
func (pc *PeerContainer) onConnectionStateChange(state webrtc.PeerConnectionState) {
	if state == webrtc.PeerConnectionStateConnected {
		pc.destroySocket()
		for len(pc.iceCandidates) > 0 {
			candidate := pc.iceCandidates[0]
			pc.iceCandidates = pc.iceCandidates[1:]
			pc.AddICECandidate(candidate)
		}
		log.Println("peer", pc.Id, "connected")
	}
	if state == webrtc.PeerConnectionStateClosed {
		pc.Destroy()
		log.Println("peer", pc.Id, "disconnected")
	}
}

func (pc *PeerContainer) AddConsumer(peer *PeerContainer) {
	pc.consumers[peer.Id] = peer
}

func (pc *PeerContainer) RmvConsumer(id int) {
	delete(pc.consumers, id)
	delete(pc.onNewTrack, id)
	delete(pc.onDestroy, id)
}

func (pc *PeerContainer) AddOnDestroyHandler(id int, fn func(*PeerContainer)) {
	pc.onDestroy[id] = fn
}

func (pc *PeerContainer) AddOnNewTrackHandler(id int, fn func(*webrtc.TrackLocalStaticRTP)) {
	pc.onNewTrack[id] = fn
}
