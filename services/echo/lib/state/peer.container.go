package state

import (
	"echo/constants"
	"echo/lib/record"
	"echo/lib/utils"
	"encoding/json"
	"errors"
	"io"
	"log"
	"time"

	"github.com/gofiber/contrib/websocket"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
)

// this describes a peer connection between the client (producer/consumer) and the server.
type PeerContainer struct {
	Id   int
	Conn *webrtc.PeerConnection

	// slice of tracks that are received from the client in the server
	Tracks []*webrtc.TrackLocalStaticRTP

	// the associated websocket connection
	Socket *websocket.Conn

	// the associated data channel container
	DataChannel *DataChannelContainer

	Destroyed bool
	onDestroy func()

	// recieved (by websocket) ice-candidates are stored here when connection is not established yet
	iceCandidates []string
}

/*
establish a webrtc peer connection by using pion webrtc. this function does
more than establishing the connection; it manages the global state of peers
connections and streams as well.

Note: it returns the peer connection with the associated id if it's already
established before, by retrieving it from the state package.
*/
func (pc *PeerContainer) InitConn() (*webrtc.PeerConnection, error) {
	if pc.Destroyed {
		return nil, errors.New("cannot initialize a connection on a destroyed peer container")
	}

	if pc.Conn != nil {
		return nil, errors.New("connection is already initialized")
	}

	mediaEngine := &webrtc.MediaEngine{}

	// Register video (vp8) codec
	if err := mediaEngine.RegisterCodec(
		webrtc.RTPCodecParameters{
			RTPCodecCapability: webrtc.RTPCodecCapability{
				MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
			},
			PayloadType: 96,
		}, webrtc.RTPCodecTypeVideo,
	); err != nil {
		panic(err)
	}

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	interceptorRegistry := &interceptor.Registry{}

	// Use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(mediaEngine, interceptorRegistry); err != nil {
		return nil, err
	}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// TODO: A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		return nil, err
	}
	interceptorRegistry.Add(intervalPliFactory)

	// Create a new RTCPeerConnection
	conn, err := webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithInterceptorRegistry(interceptorRegistry),
	).NewPeerConnection(constants.Config)

	conn.OnTrack(pc.onTrack)
	conn.OnICECandidate(pc.onICECandidate)
	conn.OnConnectionStateChange(pc.onConnectionStateChange)
	// conn.OnConnectionStateChange(func(pcs webrtc.PeerConnectionState) {
	// 	log.Printf("Peer connection state: %s", pcs.String())
	// })
	conn.OnICEConnectionStateChange(func(is webrtc.ICEConnectionState) {
		log.Printf("Ice connection state: %s", is.String())
	})
	conn.OnICEGatheringStateChange(func(is webrtc.ICEGatheringState) {
		log.Printf("Ice gathering state: %s", is.String())
	})

	conn.OnDataChannel(func(dc *webrtc.DataChannel) {
		log.Println("data channel recieved from peer", pc.Id, "with label", dc.Label())
		pc.DataChannel = &DataChannelContainer{
			Channel: dc,
			OnNewMessage: func(msg *DataChannelMsg) {
				pc.AddICECandidate(msg.NewIceCandidate)
			},
		}
		if err := pc.DataChannel.Init(); err != nil {
			log.Println("peer", pc.Id, ": failed to init data channel!")
			log.Println("error:", err)
		}
	})

	pc.Conn = conn
	return conn, err
}

func (pc *PeerContainer) AddICECandidate(candidate string) {
	if pc.Conn == nil {
		pc.iceCandidates = append(pc.iceCandidates, candidate)
		return
	}
	ice := &webrtc.ICECandidateInit{}
	if err := json.Unmarshal([]byte(candidate), ice); err != nil {
		log.Println("error:", err)
		return
	}
	if err := pc.Conn.AddICECandidate(*ice); err != nil {
		log.Println("warning: candidate couldn't be added.")
		log.Println("error:", err)
		return
	}
}

/*
This function should be used in the consume handler in order to send producer
tracks to consumers (this peer container) by using webrtc.RTPSender.
*/
func (pc *PeerContainer) SendTrack(track *webrtc.TrackLocalStaticRTP) error {
	rtpSender, err := pc.Conn.AddTrack(track)
	if err != nil {
		log.Printf(
			"Unable to add track to the peer (%d) connection: %s",
			pc.Id,
			err,
		)
		return err
	}
	// Read incoming RTCP packets
	// Before these packets are returned they are processed by interceptors. For things
	// like NACK this needs to be called.
	go func() {
		rtcpBuf := make([]byte, 1500)
		utils.IncreaseThread()
		defer utils.DecreaseThread()
		for {
			if _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {
				log.Printf(
					"Unable to read rtcp for peer %d: %s",
					pc.Id,
					rtcpErr,
				)
				return
			}
		}
	}()

	return nil
}

// close both webrtc and socket connections, and clear variables from memory
func (pc *PeerContainer) Destroy() {
	if pc.Destroyed {
		return
	}
	pc.destroyPeer()
	pc.destroySocket()
	pc.Destroyed = true
	pc.onDestroy()
}

func (pc *PeerContainer) destroyPeer() {
	if pc.Conn != nil {
		// ignore any error
		if err := pc.Conn.Close(); err != nil {
		}
	}
	if pc.DataChannel != nil {
		// ignore any error
		if err := pc.DataChannel.Destroy(); err != nil {
		}
	}
	pc.Conn = nil
	pc.DataChannel = nil
	pc.Tracks = nil
}

func (pc *PeerContainer) destroySocket() {
	if pc.Socket != nil {
		// this terminates the hanging in the ws handler for loop
		pc.Socket.SetReadDeadline(<-time.NewTimer(5 * time.Second).C)
		// ignore any error
		if err := pc.Socket.Close(); err != nil {
		}
	}
	pc.Socket = nil
}

// store different tracks received from the remote peer in the state
func (pc *PeerContainer) onTrack(remoteTrack *webrtc.TrackRemote, _ *webrtc.RTPReceiver) {
	// create a local track with the remote track capabilities
	localTrack, newTrackErr := webrtc.NewTrackLocalStaticRTP(
		remoteTrack.Codec().RTPCodecCapability,
		remoteTrack.ID(),
		remoteTrack.ID(),
	)

	if newTrackErr != nil {
		panic(newTrackErr)
	}

	pc.Tracks = append(pc.Tracks, localTrack)

	// write the buffer from the remote track in the local track simultaneously
	codec := remoteTrack.Codec()
	writer := record.GetWriter(codec)

	utils.IncreaseThread()
	defer utils.DecreaseThread()
	for {
		packet, _, readErr := remoteTrack.ReadRTP()
		record.SavePacketToDisk(writer, packet)
		if readErr != nil {
			log.Println(readErr)
			break
		}
		// ErrClosedPipe means we don't have any subscribers, this is ok if no peers have connected yet
		if err := localTrack.WriteRTP(packet); err != nil && !errors.Is(err, io.ErrClosedPipe) {
			log.Println(err)
			break
		}
	}
}

// When Pion gathers a new ICE Candidate send it to the client. This is how
// ice trickle is implemented. Everytime we have a new candidate available we send
// it as soon as it is ready. We don't wait to emit a Offer/Answer until they are
// all available
func (pc *PeerContainer) onICECandidate(candidate *webrtc.ICECandidate) {
	if candidate != nil {
		log.Printf("Ice candiate: %s/%s", candidate.Typ.String(), candidate.Protocol.String())
	}

	if candidate == nil {
		log.Printf("Got a null candiate; Ice gathering done.")
		return
	}

	if pc.Socket == nil && pc.DataChannel == nil {
		// NOTE: this should never happen as the specification is that:
		// the connection cannot be established without sockets exist, and once it's
		// established sockets are closed and replaced by data channels for further
		// communication.
		log.Println("error: neither socket nor data channel is found; should never happen!")
		return
	}

	iceInit, err := json.Marshal(candidate.ToJSON())
	if err != nil {
		log.Println("error:", err)
		return
	}

	if pc.Socket != nil {
		pc.Socket.WriteMessage(websocket.TextMessage, iceInit)
		return
	}
	pc.DataChannel.Send(DataChannelMsg{
		NewIceCandidate: string(iceInit),
	})
}

// Hanldes the container state and behaviour according to the connection state
func (pc *PeerContainer) onConnectionStateChange(state webrtc.PeerConnectionState) {
	if state == webrtc.PeerConnectionStateConnected {
		pc.destroySocket()
		for len(pc.iceCandidates) > 0 {
			candidate := pc.iceCandidates[0]
			pc.iceCandidates = pc.iceCandidates[1:]
			pc.AddICECandidate(candidate)
		}
		log.Println("peer", pc.Id, "connected")
	}
	if state == webrtc.PeerConnectionStateClosed {
		pc.Destroy()
		log.Println("peer", pc.Id, "disconnected")
	}
}
