package statev2

import (
	"echo/constants"
	"echo/lib/record"
	"echo/lib/utils"
	"encoding/json"
	"errors"
	"io"
	"log"

	"github.com/gofiber/contrib/websocket"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
)

type MemberId = int

type Member struct {
	Id                  MemberId
	Conn                *webrtc.PeerConnection
	Tracks              []*webrtc.TrackLocalStaticRTP
	Socket              *websocket.Conn
	TracksChannel       chan *webrtc.TrackLocalStaticRTP
	PeerConnectionState chan webrtc.PeerConnectionState
}

func initPeerConnection() (*webrtc.PeerConnection, error) {
	mediaEngine := &webrtc.MediaEngine{}

	// register video (vp8) codec
	if err := mediaEngine.RegisterCodec(
		webrtc.RTPCodecParameters{
			RTPCodecCapability: webrtc.RTPCodecCapability{
				MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
			},
			PayloadType: 96,
		}, webrtc.RTPCodecTypeVideo,
	); err != nil {
		panic(err)
	}

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		panic(err)
	}

	// create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	interceptorRegistry := &interceptor.Registry{}

	// use the default set of Interceptors
	if err := webrtc.RegisterDefaultInterceptors(mediaEngine, interceptorRegistry); err != nil {
		return nil, err
	}

	// register a intervalpli factory
	// this interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// this makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// TODO: A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		return nil, err
	}

	interceptorRegistry.Add(intervalPliFactory)

	// create a new peer connection
	conn, err := webrtc.NewAPI(
		webrtc.WithMediaEngine(mediaEngine),
		webrtc.WithInterceptorRegistry(interceptorRegistry),
	).NewPeerConnection(constants.Config)

	return conn, err
}

func NewMember(mid MemberId, socket *websocket.Conn) (*Member, error) {
	conn, err := initPeerConnection()
	if err != nil {
		return nil, err
	}

	member := Member{
		Id:                  mid,
		Conn:                conn,
		Tracks:              []*webrtc.TrackLocalStaticRTP{},
		Socket:              socket,
		TracksChannel:       make(chan *webrtc.TrackLocalStaticRTP),
		PeerConnectionState: make(chan webrtc.PeerConnectionState),
	}

	conn.OnTrack(member.onTrack)
	conn.OnICECandidate(member.onICECandidate)
	conn.OnConnectionStateChange(member.onConnectionStateChange)
	conn.OnICEConnectionStateChange(member.onICEConnectionStateChange)
	conn.OnICEGatheringStateChange(member.onICEGatheringStateChange)

	return &member, nil
}

func (m *Member) onTrack(remoteTrack *webrtc.TrackRemote, _ *webrtc.RTPReceiver) {
	// create a local track with the remote track capabilities
	localTrack, err := webrtc.NewTrackLocalStaticRTP(
		remoteTrack.Codec().RTPCodecCapability,
		remoteTrack.ID(),
		remoteTrack.ID(),
	)

	if err != nil {
		log.Println("[onTrack]", err)
		return
	}

	m.Tracks = append(m.Tracks, localTrack)

	m.TracksChannel <- localTrack

	// write the buffer from the remote track in the local track simultaneously
	codec := remoteTrack.Codec()
	writer := record.GetWriter(codec)

	go func() {
		utils.IncreaseThread()
		defer utils.DecreaseThread()
		for {
			packet, _, err := remoteTrack.ReadRTP()
			if err != nil {
				log.Println("[onTrack]", err)
				break
			}

			record.SavePacketToDisk(writer, packet)
			// ErrClosedPipe means we don't have any subscribers, this is ok if no peers have connected yet
			if err := localTrack.WriteRTP(packet); err != nil && !errors.Is(err, io.ErrClosedPipe) {
				log.Println("[onTrack]", err)
				break
			}
		}
	}()
}

func (m *Member) onICECandidate(candidate *webrtc.ICECandidate) {
	if candidate != nil {
		log.Printf("Ice candiate: %s/%s", candidate.Typ.String(), candidate.Protocol.String())
	}

	if candidate == nil {
		log.Printf("Got a null candiate; Ice gathering done.")
		return
	}

	ice, err := json.Marshal(candidate.ToJSON())

	if err != nil {
		log.Println("[onICECandidate]", err)
		return
	}

	m.Socket.WriteMessage(websocket.TextMessage, utils.Must(json.Marshal(
		struct {
			Kind  string `json:"kind"`
			Value string `json:"value"`
		}{
			Kind:  "candiate",
			Value: string(ice),
		},
	)))
}

func (m *Member) onConnectionStateChange(cs webrtc.PeerConnectionState) {
	log.Printf("Connection state: %s", cs.String())
	m.PeerConnectionState <- cs
}

func (m *Member) onICEConnectionStateChange(is webrtc.ICEConnectionState) {
	log.Printf("Ice connection state: %s", is.String())
}

func (m *Member) onICEGatheringStateChange(is webrtc.ICEGatheringState) {
	log.Printf("Ice gathering state: %s", is.String())
}

func (m *Member) SendTrack(track *webrtc.TrackLocalStaticRTP) error {
	rtpSender, err := m.Conn.AddTrack(track)
	if err != nil {
		log.Printf(
			"Unable to add track to peer (%d) connection: %s",
			m.Id,
			err,
		)
		return err
	}

	// Read incoming RTCP packets
	// Before these packets are returned they are processed by interceptors. For things
	// like NACK this needs to be called.
	go func() {
		utils.IncreaseThread()
		defer utils.DecreaseThread()
		rtcpBuf := make([]byte, 1500)
		for {
			if _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {
				log.Printf(
					"Unable to read rtcp for peer %d: %s",
					m.Id,
					rtcpErr,
				)
				return
			}
		}
	}()

	return nil
}
