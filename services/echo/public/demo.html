<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body style="max-width: 480px">
    My Video<br />
    <video
      id="outvideo"
      style="border: solid 2px black; border-radius: 20px; margin: 8px"
      autoplay
      muted
      preload="metadata"
    ></video>

    <br />
    Recieved Videos
    <br />
    <div id="members"></div>

    <br />

    <div
      style="
        height: 100%;
        padding: 25px;
        display: flex;
        flex-direction: column;
        gap: 5px;
      "
    >
      <div>
        <label for="peer-id">Peer Id</label>
        <input id="peer-id" type="number" />
      </div>
      <button onclick="start()">Start</button>

      <div>
        <label for="producer-peer-id">Producer Peer Id</label>
        <input id="producer-peer-id" type="number" />
      </div>
      <button onclick="consume()">Add Member</button><br />
    </div>

    <div style="margin: 20px 0px">
      <button onclick="toggleCam()">Toggle Cam</button>
      <span id="cam-status">true</span>
      <button onclick="toggleMic()">Toggle Mic</button>
      <span id="mic-status">true</span>
    </div>

    <label> Logs </label>
    <br />
    <div id="logs" style="font-family: monospace"></div>

    <br />

    <label>Local Session Description</label>
    <br />
    <textarea
      id="localSessionDescription"
      readonly="true"
      style="width: 400px; height: 400px"
    ></textarea>
    <br />

    <label> Remote Session Description </label>
    <br />
    <textarea
      id="remoteSessionDescription"
      readonly="true"
      style="width: 400px; height: 400px"
    ></textarea>
    <br />
  </body>

  <script>
    let cam = true;
    let mic = true;

    function toggleCam() {
      cam = !cam;
      document.getElementById("cam-status").innerText = cam;
    }

    function toggleMic() {
      mic = !mic;
      document.getElementById("mic-status").innerText = mic;
    }
  </script>

  <script>
    let sdp = "";
    let pc = null; // peer connection
    let ws = null; // web socket
    let dc = null; // data channel

    const candidates = [];
    const recievedCandidates = [];

    let connected = false;
    const addedMembers = [];

    setInterval(() => {
      if (!ws || ws.readyState !== 1) return;
      while (candidates.length > 0) {
        ws.send(JSON.stringify(candidates.pop()));
        console.log("new ice-candidate has been sent.");
      }
    }, 1000);

    const log = (msg) => {
      document.getElementById("logs").innerHTML += msg + "<br>";
    };

    function start() {
      if (pc) return connect();

      if (!window["WebSocket"])
        return console.error("Your browser does not support WebSockets.");

      const peerId = document.getElementById("peer-id").value;
      if (peerId === "") return alert("choose a peer id value");

      ws = new WebSocket("ws://" + document.location.host + "/ws/" + peerId);
      ws.onopen = () => console.log("ws connected.");
      ws.onclose = () => console.log("ws disconnected.");
      ws.onmessage = (event) => {
        console.log("new ice-candidate has been received.");
        if (!connected) {
          recievedCandidates.push(event.data);
          return;
        }
        while (recievedCandidates.length > 0) {
          pc.addIceCandidate(JSON.parse(recievedCandidates.pop()));
        }
        pc.addIceCandidate(JSON.parse(event.data));
      };

      pc = new RTCPeerConnection({
        iceServers: [
          {
            urls: "stun:turn.litespace.org",
            username: "litespace",
            credential: "litespace",
          },
          {
            urls: "turn:turn.litespace.org",
            username: "litespace",
            credential: "litespace",
          },
        ],
      });

      pc.oniceconnectionstatechange = (e) => {
        log(pc.iceConnectionState);
        connected = pc.iceConnectionState === "connected";
      };
      pc.onicecandidate = (event) => {
        if (event.candidate === null) {
          sdp = pc.localDescription;
          document.getElementById("localSessionDescription").value =
            JSON.stringify(sdp);
          return;
        }
        candidates.push({
          candidate: event.candidate.candidate,
          sdpMid: event.candidate.sdpMid,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
        });
      };

      dc = pc.createDataChannel("main");
      dc.addEventListener("open", (event) => {
        console.log("data channel openned");
      });
      dc.addEventListener("close", (event) => {
        console.log("data channel closed");
      });
      dc.addEventListener("message", async (event) => {
        const msg = JSON.parse(await event.data.text());
        while (recievedCandidates.length > 0) {
          pc.addIceCandidate(JSON.parse(recievedCandidates.pop()));
        }
        if (msg.newIceCandidate !== "") {
          pc.addIceCandidate(JSON.parse(msg.newIceCandidate));
          console.log("new ice-candidate has been received.");
        }
      });

      // create two transceiver for each member.
      // @NOTE: assuming max number of members is ten.
      // @NOTE: assuming the first two transceivers are the one used by
      // this client to send tracks. And others are recievers.
      for (i = 0; i < 3; i++) {
        pc.addTransceiver("audio");
        pc.addTransceiver("video");
      }

      pc.ontrack = function (event) {
        console.log(event.streams);
      };

      navigator.mediaDevices
        .getUserMedia({ video: cam, audio: mic })
        .then((stream) => {
          stream.getTracks().forEach((track) => pc.addTrack(track, stream));
          document.getElementById("outvideo").srcObject = stream;
          pc.createOffer()
            .then((d) => {
              pc.setLocalDescription(d);
              setTimeout(() => connect(), 3000);
            })
            .catch(log);
        })
        .catch(log);
    }

    function connect() {
      const peerId = document.getElementById("peer-id").value;
      if (peerId === "") return alert("choose a peer id value");

      fetch("/connect", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          peerId: Number(peerId),
          sessionDescription: sdp,
        }),
      })
        .then((res) => res.json())
        .then((res) => {
          pc.setRemoteDescription(res);
          document.getElementById("remoteSessionDescription").value =
            JSON.stringify(res);
        })
        .catch(log);
    }

    function consume() {
      if (!connected) return alert("not connected yet!");
      const peerId = document.getElementById("peer-id").value;
      if (peerId === "") return alert("choose a peer id value");

      const producerPeerId = document.getElementById("producer-peer-id").value;
      if (producerPeerId === "")
        return alert("choose a producer peer id value");

      fetch("/consume", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          peerId: Number(peerId),
          producerPeerId: Number(producerPeerId),
        }),
      })
        .then(() => {
          log(`consuming from ${producerPeerId}`);
          addMember();
        })
        .catch(log);
    }

    function addMember() {
      const peerId = document.getElementById("producer-peer-id").value;
      if (peerId === "") return alert("choose a peer id value");
      if (addedMembers.includes(peerId)) return alert("member already exists!");

      addVideo(getSlot());

      addedMembers.push(peerId);
    }

    function addVideo(tracks) {
      const membersDiv = document.getElementById("members");
      if (!membersDiv) return alert("members div not found!");

      const video = document.createElement("video");
      video.setAttribute(
        "style",
        "border: solid 2px black; border-radius: 20px; margin: 8px"
      );
      video.autoplay = true;
      video.preload = "metadata";

      const stream = new MediaStream();
      const [t1, t2] = tracks;

      t1.onunmute = () => {
        video.srcObject = null;
        video.srcObject = new MediaStream([t1, t2]);
      };

      t2.onunmute = () => {
        video.srcObject = null;
        video.srcObject = new MediaStream([t1, t2]);
      };

      stream.addTrack(t1);
      stream.addTrack(t2);

      video.srcObject = null;
      video.srcObject = stream;

      membersDiv.appendChild(video);

      video.onloadedmetadata = () => {
        console.log("video metadata loaded");
        video.pause();
        video.play().catch((e) => console.error(e));
      };

      return video;
    }

    function getSlot() {
      const trs = pc.getTransceivers();
      let i = 2; // skip the sending transceiver
      for (; i < trs.length; i += 2) {
        if (trs[i].receiver.track.onunmute === null) {
          return [trs[i].receiver.track, trs[i + 1].receiver.track];
        }
      }
      return [];
    }
  </script>
</html>
